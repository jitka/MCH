%  3.2. Stage 2: Search query
%    - Explain MCHq in natural language here.
%      Get inspiration from what you wrote on whiteboard yesterday. 
%      Feel free to use some numbered lists to make it easy to read and understand.
%      If needed, make and use some graph pictures.
%    - Show the MCHq pseudocode.

\subsection{Stage 2: Search query}
\label{subsecStage2}

Multi-weighted contraction hierarchies query (MCHq) 
is based on bi-directional search.
Each $s$-$t$ query run two MLS-like searches slightly modified preprocessed graph
and then sum they results.

Both forward and reverse search have
structure open\_labels implemented as priority queue which orders labels
alphabetically.
MCHq searches on slightly modified graphs. 
We do not transform the whole graph in advance but modify it during queries.

\paragraph*{Forward search}
Forward search use preprocessed graph with edges oriented from the node with lower rank to nodes with higher rank.
This could by done by replacing line \todo{budu predelavat sazbu pseudokodu aby to slo} by \ref{}
It run Meta Search algorithm with the query from node $s$ to $t$ and return all label bug.
Line TODO could by replaced by:

\begin{lstlisting}[caption={MCHp},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
    for every outgoing edge e=(node(l),w):
    	if rank(node(l)) < rank(w):
        	continue;
\end{lstlisting}

\paragraph*{Reverse search}
Reverse search use graph with all edges reversed and then keep only edges
from lower rank to higher. 
This could by done by replacing line \todo{budu predelavat sazbu pseudokodu aby to slo} by \ref{}
It run Meta Search algorithm with the query from node $t$ to $s$ and return all label bug.

\begin{lstlisting}[caption={MCHp},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
    for every outgoing edge e=(w, node(l)):
    	if rank(w) < rank(node(l)):
        	continue;
\end{lstlisting}

To find paths in preprocessed graph it combine labels from forward and reverse search. 
For all nodes $v$ with $B(v) \ne \emptyset$ we join all combination of $s$-$v$ and $v$-$t$ paths. 
All non-dominated paths determine Pareto set of shortest $s$-$t$ path in preprocessed graph.

Pareto set of shortest path in the original graph could be reconstructed recursively
using note on shortcuts.

