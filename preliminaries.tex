% 2. Preliminaries
%  - First, let's define MOSP (graph, solutions, etc.).
%  - We're going to be using MLS algorithm in our solution. 
%    MLS alg. is ... (explain it here instead of its own section)

\section{Preliminaries}
\label{secPreliminaries}


First, let's define Multi-Objective Shortest Path Problem (MOSP).

Let $G(V,A)$ be a directed graph where $V$ is set of nodes and $E$ set
of edges with $|V| = n$ and $|E| = m$. In multi graph we permit multiedges
$(u,v)_0,(u,v)_1,\dots)$. For fixed node $v$ in-edge is $(u,v)_i$ and out-edge
$(v,w)_j$.

Each node has \emph{weight} given by weight function
$w: E \leftarrow \mathbb{R+}^d$.
Dimension $d$ is number of weights or criteria or objective. 
In our experiments we consider $d=2,3$.
Vector $a$ is dominated by vector $b$ ($a,b \in \mathbb{R+}^d$) if
$b$ has at least one weight lower than $a$ and no weight higher than $a$.

Sequence of edges $(s=u_0,u_1)_*,(u_1,u_k)_*,\dots(u_{k-1},t=u_k)$ is called
\emph{path} $p_{s,t}$. Length of path is sum of their weights 
$w(p_{s,t}) = \Sigma_{i=0}^{i<k} (u_i,u_{i+1})$.
Set of all nondomated paths between $s,t$ is called Pareto set
$P(s,t)$.


%\subsection{Meta Search Algorithm}

Many of search algorithm which we consider
are closed to original dijkstra algorithm \cite{dijkstra1959note}
or to multi-criteria labelling setting (MLS) \cite{martins1984multicriteria}
We present its generalization in order establish the notation.

MLS search works on multi-weighted directed multi-graphs. 
Search algorithm answers three types of queries.
\begin{itemize}
\item Find all non-dominated shortest path from source node $s$ to target node $t$.
    % TODO přepsat s t na o d (origin destination)
\item Find all non-dominated shortest path from $s$ to every $t \in T \subseteq V$.
\item Find all non-dominated shortest path from $s$ to every other vertex in the graph.
\end{itemize}

Key part of all algorithm are \emph{labels} $l\in \mathcal{R}^d$.
Each label $l$ of node $v$ remember length $w(l)$  of one 
possible path from $s$ to $v$, $node(l) = v$ is name of its node
and $prev(l)$ is node previous node on path from $s$ to $v$.
Each nodes have set of non-dominated labels called \emph{label bag} $B(v)$.

Set up algorithm by creating labels.

\begin{gather*} 
B(s)=0^d, B(v)=\emptyset \forall v \ne s.
\end{gather*} 

In each step of the algorithm some label is \emph{expanded}. 
All its outgoing edges are considered. 
The outgoing edge plus path to label represents 
path which we add to the corresponding bag then check if there
is label which dominates another.

Structure open\_labels is a priority queue with all labels which was created but not expanded.
Priority function has to guarantee that top label is not dominated by any other label in that
queue an any time.

Algorithm stop when every label was expanded at that time
labels in bags $B(t), t \in T$ are lengths of paretoset of shortest path.
Path could by found recursively using $prev(l)$.

\todo[inline]{je třeba dokazovat korektnost nebo je to zjevne ci zname?}

\begin{lstlisting}[caption={MLS Algorithm},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
Input: source node s, set of target nodes T
for all nodes v:
	B(v) <- \emptyset
B(s) <- 0^d
B(t) <- \infinity^d for all t \in T
open_labels <- s
while open_labels is not empty:
	l <- some label from open_labels
    if w(l) is dominated by all labels in B(t) \in T
    	continue
    for every outgoing edge e=(node(l),w)_i
    	for every label k from bag B(w):
        	if k is dominated by l+w(e):
            	remove k from bag B(w)
        if l+w(e) is not dominated by any label from B(w)
        	add new label with weight (l+w(e)) to B(w)
Output: B(t) for every t \in T
\end{lstlisting}
\todo[inline]{sazba pseudokodu}
