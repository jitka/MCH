
\section{Formalization}
% Preliminaries
multigraph 
multiweigthd
directed
in-edge out-edge
dominated
s-t query
path
shortest path - one of nondominated = element of paretoset
$w$ is weight function $w: E \leftarrow \mathbb{R+}^d$
Edges $(u,v)_0,(u,v)_i$
Directed multiweighted $G$ with
$n$ nodes,
$m$ edges, 
higway dimension $h$,
maximum degree $\Delta$
Pareto set $\Pi(s,t)$ $P_{s,t}$
diametr $D \in \mathbb{R+}^d$

When there are two edges $(u,v)$ with same nodes we count them
separately. 


Let $G = (V,E)$ be a directed graph with length
$l: E$ 
$ \rightarrow $
$\mathcal{R+}^d$, 
where $d \in \mathcal{N}$ is
dimension. In our experimental results
we consider $d=2, d=3$.

For each path $P(s,d)$ we denote 
$l(P) = \Sigma_{e\in P} l(e) $
length of path $P$.
Let $P(u,v)$ denote the \emph{pareto set} of shortest path.

Given a non-negative $r \in \mathcal{}{N}^d $, let $B_{u,r} = 
\{ v \in V, |P(u,v)| \le r \} $.
Directed ball


\section{Algorithms}

\subsection{Meta Search Algorithm}

Many of search algorithm which we consider
are closed to original dijkstra algorithm \cite{dijkstra1959note}.
We present its generalization in order establish the notation.

Meta search works on multi-weighted directed multi-graphs. 
Search algorithm answers three types of queries.
\begin{itemize}
\item Find all non-dominated shortest path from source node $s$ to target node $t$.\todo{je to vhodne pojmenovani?}
\item Find all non-dominated shortest path from $s$ to every $t \in T \subseteq V$.
\item Find all non-dominated shortest path from $s$ to every other vertex in the graph.
\end{itemize}

Key part of all algorithm are \emph{labels} $l\in \mathcal{R}^d$.
Each label $l$ of node $v$ remember length $w(l)$  of one 
possible path from $s$ to $v$, $node(l) = v$ is name of its node
and $prev(l)$ is node previous node on path from $s$ to $v$.
Each nodes have set of non-dominated labels called \emph{label bag} $B(v)$.

Set up algorithm by creating labels.

\begin{gather*} 
B(s)=0^d, B(v)=\emptyset \forall v \ne s.
\end{gather*} 

In each step of the algorithm some label is \emph{expanded}. 
All its outgoing edges are considered. 
The outgoing edge plus path to label represents 
path which we add to the corresponding bag then check if there
is label which dominates another.

open\_labels is set of all labels which was created but not expanded.

Algorithm stop when every label was expanded at that time
labels in bags $B(t), t \in T$ are lengths of paretoset of shortest path.
Path could by found recursively using $prev(l)$.

\todo{je třeba dokazovat korektnost nebo je to zjevne ci zname?}

\begin{lstlisting}[caption={Meta Search Algorithm},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
Input: source node s, set of target nodes T
for all nodes v:
	B(v) <- \emptyset
B(s) <- 0^d
B(t) <- \infinity^d for all t \in T
open_labels <- s
while open_labels is not empty:
	l <- some label from open_labels
    if w(l) is dominated by all labels in B(t) \in T
    	continue
    for every outgoing edge e=(node(l),w)_i
    	for every label k from bag B(w):
        	if k is dominated by l+w(e):
            	remove k from bag B(w)
        if l+w(e) is not dominated by any label from B(w)
        	add new label with weight (l+w(e)) to B(w)
Output: B(t) for every t \in T
\end{lstlisting}
\todo{psat pseudokod v tomhe (doporucuje examle pro tu konference) nebo v necem co umi zobrazit symboly? }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Multi-weighted Contraction Hierarchies}
We propose a Multi-weighted Contraction Hierarchies (MCH) for finding the Pareto set
of optimal paths in multi-weighted directed multi-graphs. 
MCH consist of two separate algorithm preprocessing and query,
both algorithms are based on Contraction Hiearchies 
for single-weighted undirected graphs \cite{geisberger2008contraction}.


Preprocessing algorithm (MCHp) takes the multi-weighted directed multigraph
and returns preprocessed graph. MCHp contracts nodes one by one. 
When node is conrtacted algorithm add new edges called \emph{shortcuts} in order
to keep all Pareto optimal shortest path distances. 
Preprocessed graph has same set of nodes as the original graph.
Nodes are has \emph{rank} which correspond to order of contraction.
$rank(v) \in \{0,..n-1\}$
Preprocessed graph has all original edges $E$ and shorthus $E+$.
Each shortcut $(u,v)_i$ represent 
path in original graph $p_{u,v}$, $w((u,v)) = w(p_{u,v})$ and it have a note which helps
to reconstruct the original path.

Query algorithm (MCHq) use preprocessed graph to found Pareto set of all
shortest path between two nodes $s, t$. MCHq runs search algorithms
from both $s, t$. 
It joins results to the path in preprocessed graph 
and then reconstruct path in the original graph.

\subsubsection{Preprocessing MCHp}

Preprocessing contract all nodes one by one from least important to the most important. 
Cost vector of all paths between two nodes has to last after contraction.

We suppose that we have some function which denotes least important vertex of the graph. For theoretical results, we consider function based on Highway Dimension
(see todo)  for computational results see todo.

At $i$-th step least important node $v$ got $rank(v) = i$ and is \emph{contracted}. 
Contraction of node $v$ consists removing and archiving all edges adjacent $v$, removing 
and archiving node $v$ and adding shortcuts. 

To found shortcuts, we run witness search, which returns paths from all nodes which had
out-edge to $v$ and all nodes which have in-edge from $v$. 
For every pair edges $(u,v)_i,(v,w)_j$ we check 
if path $p_{\{u,v,w\}}$ is dominated by any path from witness search. 
If not, then we add shortcut between these two nodes with a note 
saying which node was contracted.
By that process, new multi-edges could be created.
\todo{je treba vysvetlovat vic?}

When all node was removed all nodes and edges of preprocessed graph are in the archive.

\begin{lstlisting}[caption={MCHp},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
Input: Graph G
for i from 0 to n-1
    v <- least important node
    rank(v) = i
    witnesses <- witness search
    for every pair of edges (u,v)_i,(v,w)_j:
    if p(u,v,w) is not dominated by any witness:
        add shortcut (u,w)_0
            w((u,w)_0) = w((u,v)_i)+w((v,w)_j)
            note((u,w)) = v
    archive all out-edges (v,w) 
    archive all in-edges (u,v)
    archive v
Output: Archived nodes, edges, rank of nodes.
\end{lstlisting}


\paragraph*{Witness search}

Witness search is used to found which shortcut we need to add when we contract 
node $v$.

For each in-edge $(u_i,v)_j$ we run separate search which founds all shortcuts 
from $u_i$.

We use an algorithm based on Meta Search Algorithm. 
open\_labels 
is implemented as a priority queue with alphabetical ordering. Top of quote contain labels with the lowest first weight which are ordered by second weight and so on. 
In such ordering, each label comes after all open labels which dominate it.

It is possible to set up time limit on witness search. The algorithm is stopped after the time limit. Some witnessing paths could by missing and unnecessary shortcut are added, but it does not violate correctness of the algorithm.

\subsubsection{Query MCHq}

Each $s$-$t$ query is based on bi-directional search.
Both searches are based on Meta search algorithm with priority queue which orders labels
alphabetically. It searches on slightly modified graphs. We do not transform the whole
graph in advance but modify it during queries.

\emph{Forward search} use graph with edges
oriented from the node with lower rank to nodes with higher rank.
We run Meta Search algorithm with the query from node $s$ to $t$ and use all label bug.
Line TODO could by replaced by:

\begin{lstlisting}[caption={MCHp},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
    for every outgoing edge e=(node(l),w):
    	if rank(node(l)) < rank(w):
        	continue;
\end{lstlisting}

\emph{Reverse search} use graph whit all edges reversed and then keep only edges
from lower rank to higher. 
The reverse search runs Meta Search algorithm with the query from node $t$ to $s$ and uses all label bug.
Line TODO could by replaced by:

\begin{lstlisting}[caption={MCHp},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
    for every outgoing edge e=(w, node(l)):
    	if rank(w) < rank(node(l)):
        	continue;
\end{lstlisting}

To find paths in preprocessed graph is combine labels from forward and reverse search. 
For all nodes $v$ with $B(v) \ne \emptyset$ we join all combination of $s$-$v$ and $v$-$t$ paths. 
All non-dominated paths determine Pareto set of shortest $s$-$t$ path in preprocessed set.

Original paths could be reconstructed recursively.
Each shortcut $(u,v)_i$ could be decomposed either by using note or 
by comparing all out-edges of $u$ and all in-edges of $v$.



% TODO
%vic popsat uvod - nazvy
%nazvat veci
%Rozumne dělení, nadpisy
%PSEUDOKOD
%mohou vztikat multihrany
% updatovani

\section{Formal results}
\begin{lemma}
%[Lemma]
Set of edges found by query is Pareto set of shortest paths.
\end{lemma}
\begin{proof}
\begin{itemize}
\item[$\subseteq$] 

Let $p_{s,t}$ be arbitrary path from Pareto set $P(s,t)$. 

Suppose that $t$ is the most important node in the path $p_{s,t}$, 
then path $p_{s,t}$ should be found by forward search
and together with path $p_{t,t}$, $l(p_{t,t})=0$ 
founded by backward search its represents original path.
If $p_{s,t}$ is the single edge, then forward search founds it.
If $p$ is the second most important node, then we denote $v$ the
third most important node. 
By the time when $w$ was contracting, all other nodes had been contracted
and $s,t$ was adjacent to $v$. So the shortcut $(s,t)_j$ was created, and forward search uses it.
If $v \ne s$ is the second most important node on the path,
then the sub-path $p_{s,v}$ is found by the forward search by induction and
then sub-path $p_{v,t}$ is also found by the forward search.

The case when $s$ is the most important node on path $p_{s,t}$ is very similar. 

Let $v$ be the most important node on path $p_{s,t}$. 
Sub-path $p_{s,v} \in \Pi(s,v)$ 
if not than the $p' \in \Pi(s,v)$ which dominates $p_{s,v}$ could be substituted
to $p_{s,t}$ and the resulting paths $p'_{s,t}$ dominates $p_{s,t}$ which contradict
$p \in \Pi(s,t)$.
Similarly, $p_{v,t} \in \Pi(v,t) $. Path $p_{s,v}$ is found by forward search end path
$p_{v,t}$ by backward search.

\item[$\supseteq$] 
Each path found by multi-weighted CH corresponds to the path in the original graph. 

\end{itemize}
\end{proof}

\subsection{Highway dimension}

% TODO (origin-destinetion) 

Parameter Highway Dimension was introduced in \cite{abraham2010highway}.
There are few slightly different definition. 
We use definition based on (\cite{abraham2016highway}, Lemma 4.3)
which  use \emph{ Sparse Shortest Path Hitting Set (SPHS)}.
This definition could be easily transformed for multi-weighted directed
multi-graphs. We changed definition of ball and multiscale SHPS.


\begin{definition}
Given a non-negative vector $r \in \mathbb{R}^+$, let 
$B_{u,r} = \{v \in V, |P(u, v)| \le r \}$ 
be the ball of radius $r$ centered at $u$.
\end{definition}

\begin{definition}
Given a set of paths $P$, we say that $H \subseteq V$ is a hitting set for $P$ if every
path in $P$ contains a vertex in $H$. 
\end{definition}

\begin{definition}
For $r > 0$, an $(h, r)-$SPHS is a hitting set $C \subseteq V$ such that
$\forall v \in V, |B_{2r} (v) \cap C| \le h$.
\end{definition}

\begin{definition}
Let $D$ be the diameter and $k = \log(\max(D))$ logarithm of value of its biggest coordinates. 
$D_k = D$, when $D_i$ is vector $(w_0,w_1,\dots)$ then $D_{i-1} = (w_0/2,w_1/2,\dots)$. 
A \emph{multiscale SPHS} of $(G,w)$ is a collection of sets $C_{D_i}$ for $0 \le i \le k$.
\end{definition}

\begin{definition}
If the highway dimension of $(G,w)$ is h, then there exists a multiscale
SPHS such that $|C_{\log D}| \le h$ and $|C_i| \le h|C_{i+1}|$ for $0 \le i < \log D$.
\end{definition}

In order to get time and space estimates of MCHp and MCHq we need to count shortcuts in
the graph. Let $Q_{D_i} = C_{D_i} \setminus \Cup^{k}_{j=i+1}C_{D_j}$.

\begin{lemma}
For fixed $v$ and $j$, the number of shortcuts $(v,w)$ with $w\in Q_j$ is at most $h$.
\end{lemma}

\begin{theorem}
\label{shrotcutsNumber}
If $(G,w)$ has highway dimension h, then preprocessing based on
multiscale SPHS produces a set of shortcuts $E+$ such that degree of every vertex in
$G(V, E \cup E+)$ is at most $h + h \log D$ and $|E+| \le nh\log D$.
\end{theorem}

The proof is exactly same as in (\cite{abraham2016highway}, Lemma 6.1, Theorem 6.2)

Time complexity of MCHp 

Time complexity of MCHq. By theorem \ref{shrotcutsNumber} we know that degree is 
bounded by $h \log D$. When the Meta Search Algorithm use Fibonacci heaps  


% During query faze we can use bidirectional search 
% \cite{ma2013using}
% with heuristic. 


% There is an ordering of vertices
% such that CH query with range optimization takes
% O((∆ + h log D)(h log D)) time, and a poly-time computable
% ordering such that the query takes O((∆ +
% h log n log D)(h log n log D)) time.

% Theorem 5.3. Consider the variant of CH with additional
% shortcuts. The total number of shortcut
% edges is bounded by |E∗
% | = O(nh log D) or
% O(nh log n log D) for poly-time preprocessing. The
% query takes O((∆ + h log D)(h log D)) time or O((∆ +
% h log n log D)(h log n log D)) for polynomial-time preprocessing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

